(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory());
})(this, (function () { 'use strict';

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;

  const NoFlags = 0b0000000; // 0
  const Placement = 0b0000010; // 2
  const Update = 0b0000100; // 4
  const ChildDeletion = 0b0001000; // 8
  const MutationMask = Placement | Update | ChildDeletion;

  class FiberNode {
      tag; // 类型；
      key; // 唯一标识；
      stateNode; // 节点对应的实际 DOM 节点或组件实例；
      type; // 节点的类型，可以是原生 DOM 元素、函数组件或类组件等；
      return; // 指向节点的父节点；
      sibling; // 指向节点的下一个兄弟节点；
      child; // 指向节点的第一个子节点；
      index; // 索引；
      ref; // 指向节点的 ref 属性；
      pendingProps; // 表示节点的新属性，用于在协调过程中进行更新。
      memorizedPros; // 已经更新完的属性
      memorizedState; // 更新完成后新的 State
      alternate; // 指向节点的备份节点，用于在协调过程中进行比较；
      flags; // 表示节点的副作用类型，如更新、插入、删除等；
      subtreeFlags; // 表示子节点的副作用类型，如更新、插入、删除等；
      updateQueue; // 更新计划队列
      constructor(tag, pendingProps, key) {
          // 类型
          this.tag = tag;
          this.key = key;
          this.ref = null;
          this.stateNode = null; // 节点对应的实际 DOM 节点或组件实例
          this.type = null; // 节点的类型，可以是原生 DOM 元素、函数组件或类组件等
          // 构成树状结构
          this.return = null; // 指向节点的父节点
          this.sibling = null; // 指向节点的下一个兄弟节点
          this.child = null; // 指向节点的第一个子节点
          this.index = 0; // 索引
          // 作为工作单元
          this.pendingProps = pendingProps; // 表示节点的新属性，用于在协调过程中进行更新
          this.memorizedPros = null; // 已经更新完的属性
          this.memorizedState = null; // 更新完成后新的 State
          this.alternate = null; // 指向节点的备份节点，用于在协调过程中进行比较
          this.flags = NoFlags; // 表示节点的副作用类型，如更新、插入、删除等
          this.subtreeFlags = NoFlags; // 表示子节点的副作用类型，如更新、插入、删除等
          this.updateQueue = null; // 更新计划队列
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          // 将根节点的 stateNode 属性指向 FiberRootNode，用于表示整个 React 应用的根节点
          hostRootFiber.stateNode = this;
          // 指向更新完成之后的 hostRootFiber
          this.finishedWork = null;
      }
  }
  // 根据 FiberRootNode.current 创建 workInProgress
  const createWorkInProgress = (current, pendingProps) => {
      let workInProgress = current.alternate;
      if (workInProgress == null) {
          // 首屏渲染时（mount）
          workInProgress = new FiberNode(current.tag, pendingProps, current.key);
          workInProgress.stateNode = current.stateNode;
          // 双缓冲机制
          workInProgress.alternate = current;
          current.alternate = workInProgress;
      }
      else {
          // 非首屏渲染时（update）
          workInProgress.pendingProps = pendingProps;
          // 将 effect 链表重置为空，以便在更新过程中记录新的副作用
          workInProgress.flags = NoFlags;
      }
      // 复制当前节点的大部分属性
      workInProgress.type = current.type;
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.child = current.child;
      workInProgress.memorizedPros = current.memorizedPros;
      workInProgress.memorizedState = current.memorizedState;
      return workInProgress;
  };
  // 根据 DOM 节点创建新的 Fiber 节点
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type == 'string') {
          // 如: <div/> 的 type: 'div'
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function' && true) {
          console.warn('未定义的 type 类型', element);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }

  // 创建 Update 实例的方法
  const createUpdate = (action) => {
      return {
          action
      };
  };
  // 创建 UpdateQueue 实例的方法
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null
          },
          dispatch: null
      };
  };
  // 将 Update 添加到 UpdateQueue 中的方法
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update;
  };
  // 从 UpdateQueue 中消费 Update 的方法
  const processUpdateQueue = (baseState, pendingUpdate) => {
      const result = {
          memorizedState: baseState
      };
      if (pendingUpdate !== null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              // 若 action 是回调函数：(baseState = 1, update = (i) => 5i)) => memorizedState = 5
              result.memorizedState = action(baseState);
          }
          else {
              // 若 action 是状态值：(baseState = 1, update = 2) => memorizedState = 2
              result.memorizedState = action;
          }
      }
      return result;
  };

  // packages/shared/ReactSymbols.ts
  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  // 表示普通的 React 元素，即通过 JSX 创建的组件或 DOM 元素
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7;

  function ChildReconciler(shouldTrackSideEffects) {
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const fiber = createFiberFromElement(element);
          fiber.return = returnFiber;
          return fiber;
      }
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          // 首屏渲染且追踪副作用时，才添加标记
          if (shouldTrackSideEffects && fiber.alternate == null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      // 闭包，根绝 shouldTrackSideEffects 返回不同 reconcileChildFibers 的实现
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断当前 fiber 的类型
          // 单个 Fragment 节点
          if (typeof newChild == 'object' && newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('未实现的 reconcile 类型', newChild);
                      }
                      break;
              }
          }
          // 多个 Fragment 节点
          if (Array.isArray(newChild)) {
              // TODO: 暂时不处理
              {
                  console.warn('未实现的 reconcile 类型', newChild);
              }
          }
          // 文本节点
          if (typeof newChild == 'string' || typeof newChild == 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          {
              console.warn('未实现的 reconcile 类型', newChild);
          }
          return null;
      };
  }
  // 组件的更新阶段中，追踪副作用
  const reconcileChildFibers = ChildReconciler(true);
  // 首屏渲染阶段中不追踪副作用，只对根节点执行一次 DOM 插入操作
  const mountChildFibers = ChildReconciler(false);

  const currentDispatcher$1 = {
      current: null
  };

  // 内部数据共享层
  const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
      currentDispatcher: currentDispatcher$1
  };

  // packages/shared/internals.ts
  // 为了将 react-reconciler 和 react 解耦，在 shared 中转，方便 react-reconciler 使用
  const internals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  /* eslint-disable @typescript-eslint/no-explicit-any */
  // 当前正在处理的 FiberNode
  let currentlyRenderingFiber = null;
  // Hooks 链表中当前正在处理的 Hook
  let workInProgressHook = null;
  const { currentDispatcher } = internals;
  // 执行函数组件中的函数
  function renderWithHooks(workInProgress) {
      // 赋值
      currentlyRenderingFiber = workInProgress;
      workInProgress.memorizedState = null;
      // 判断 Hooks 被调用的时机
      const current = workInProgress.alternate;
      if (current !== null) {
          // 组件的更新阶段(update)
          currentDispatcher.current = HooksDispatcherOnUpdate;
      }
      else {
          // 首屏渲染阶段(mount)
          currentDispatcher.current = HooksDispatcherOnMount;
      }
      // 函数保存在 type 字段中
      const Component = workInProgress.type;
      const props = workInProgress.pendingProps;
      // 执行函数
      const children = Component(props);
      // 重置
      currentlyRenderingFiber = null;
      workInProgressHook = null;
      return children;
  }
  const HooksDispatcherOnMount = {
      useState: mountState
  };
  const HooksDispatcherOnUpdate = {
      useState: updateState
  };
  function mountState(initialState) {
      // 当前正在处理的 useState
      const hook = mountWorkInProgressHook();
      // 获取当前 useState 对应的 Hook 数据
      let memorizedState;
      if (initialState instanceof Function) {
          memorizedState = initialState();
      }
      else {
          memorizedState = initialState;
      }
      hook.memorizedState = memorizedState;
      const queue = createUpdateQueue();
      hook.queue = queue;
      // @ts-ignore
      // 实现 dispatch
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [memorizedState, dispatch];
  }
  function updateState(initialState) {
      // TODO
      throw new Error('Function not implemented.');
  }
  function mountWorkInProgressHook() {
      const hook = {
          memorizedState: null,
          queue: null,
          next: null
      };
      if (workInProgressHook == null) {
          // mount 时的第一个hook
          if (currentlyRenderingFiber !== null) {
              workInProgressHook = hook;
              currentlyRenderingFiber.memorizedState = workInProgressHook;
          }
          else {
              // currentlyRenderingFiber == null 代表 Hook 执行的上下文不是一个函数组件
              throw new Error('Hooks 只能在函数组件中执行');
          }
      }
      else {
          // mount 时的其他 hook
          // 将当前处理的 Hook.next 指向新建的 hook，形成 Hooks 链表
          workInProgressHook.next = hook;
          // 更新当前处理的 Hook
          workInProgressHook = hook;
      }
      return workInProgressHook;
  }
  // 用于触发状态更新的逻辑
  function dispatchSetState(fiber, updateQueue, action) {
      const update = createUpdate(action);
      enqueueUpdate(updateQueue, update);
      // 调度更新
      scheduleUpdateOnFiber(fiber);
  }

  // 比较并返回子 FiberNode
  const beginWork = (workInProgress) => {
      switch (workInProgress.tag) {
          case HostRoot: // 根节点
              return updateHostRoot(workInProgress);
          case HostComponent: // 原生 DOM 元素节点，例如 <div>、<span> 等
              return updateHostComponent(workInProgress);
          case HostText: // 文本节点
              return updateHostText();
          case FunctionComponent: // 函数组件
              return updateFunctionComponent(workInProgress);
          default:
              {
                  console.warn('beginWork 未实现的类型', workInProgress.tag);
              }
              break;
      }
  };
  function updateHostRoot(workInProgress) {
      // 根据当前节点和工作中节点的状态进行比较，处理属性等更新逻辑
      const baseState = workInProgress.memorizedState;
      const updateQueue = workInProgress.updateQueue;
      const pending = updateQueue.shared.pending;
      // 清空更新链表
      updateQueue.shared.pending = null;
      // 计算待更新状态的最新值
      const { memorizedState } = processUpdateQueue(baseState, pending);
      workInProgress.memorizedState = memorizedState;
      // 处理子节点的更新逻辑
      const nextChildren = workInProgress.memorizedState;
      reconcileChildren(workInProgress, nextChildren);
      // 返回新的子节点
      return workInProgress.child;
  }
  function updateHostComponent(workInProgress) {
      const nextProps = workInProgress.pendingProps;
      const nextChildren = nextProps.children;
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  function updateHostText() {
      // 没有子节点，直接返回 null
      return null;
  }
  function updateFunctionComponent(workInProgress) {
      const nextChildren = renderWithHooks(workInProgress);
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  /**
   * 通过对比子节点的 current FiberNode 与 子节点的 ReactElement，
   * 来生成子节点对应的 workInProgress FiberNode。
   * （current 是与视图中真实 UI 对应的 Fiber 树，workInProgress 是触发更新后正在 Reconciler 中计算的 Fiber 树。）
   */
  function reconcileChildren(workInProgress, children) {
      // alternate 指向节点的备份节点，即 current
      const current = workInProgress.alternate;
      if (current !== null) {
          // 组件的更新阶段
          workInProgress.child = reconcileChildFibers(workInProgress, current?.child, children);
      }
      else {
          // 首屏渲染阶段
          workInProgress.child = mountChildFibers(workInProgress, null, children);
      }
  }

  const createInstance = (type, porps) => {
      // TODO: 处理 props
      const element = document.createElement(type);
      return element;
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child);
  };
  const createTextInstance = (content) => {
      const element = document.createTextNode(content);
      return element;
  };
  const appendChildToContainer = (child, parent) => {
      parent.appendChild(child);
  };

  // packages/react-reconciler/src/completeWork.ts
  // 生成更新计划，计算和收集更新 flags
  const completeWork = (workInProgress) => {
      const newProps = workInProgress.pendingProps;
      const current = workInProgress.alternate;
      switch (workInProgress.tag) {
          case HostRoot:
          case FunctionComponent:
              bubbleProperties(workInProgress);
              return null;
          case HostComponent:
              if (current !== null && workInProgress.stateNode !== null) ;
              else {
                  // 首屏渲染阶段
                  // 构建 DOM
                  const instance = createInstance(workInProgress.type);
                  // 将 DOM 插入到 DOM 树中
                  appendAllChildren(instance, workInProgress);
                  workInProgress.stateNode = instance;
              }
              // 收集更新 flags
              bubbleProperties(workInProgress);
              return null;
          case HostText:
              if (current !== null && workInProgress.stateNode !== null) ;
              else {
                  // 首屏渲染阶段
                  // 构建 DOM
                  const instance = createTextInstance(newProps.content);
                  workInProgress.stateNode = instance;
              }
              // 收集更新 flags
              bubbleProperties(workInProgress);
              return null;
          default:
              {
                  console.warn('completeWork 未实现的类型', workInProgress);
              }
              return null;
      }
  };
  /**
   * 负责递归地将组件的子节点添加到指定的 parent 中，
   * 它通过深度优先遍历 workInProgress 的子节点链表，处理每个子节点的类型。
   * 先处理当前节点的所有子节点，再处理兄弟节点。
   *
   * 如果它是原生 DOM 元素节点或文本节点，则将其添加到父节点中；如果是其他类型的组件节点并且有子节点，则递归处理其子节点。
   */
  function appendAllChildren(parent, workInProgress) {
      let node = workInProgress.child;
      while (node !== null) {
          if (node.tag == HostComponent || node.tag == HostText) {
              // 处理原生 DOM 元素节点或文本节点
              appendInitialChild(parent, node.stateNode);
          }
          else if (node.child !== null) {
              // 递归处理其他类型的组件节点的子节点
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node == workInProgress) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                  return;
              }
              node = node.return;
          }
          // 处理下一个兄弟节点
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  /**
   * 负责在 completeWork 函数向上遍历的过程中，通过向上冒泡子节点的 flags，将所有更新 flags 收集到根节点。
   * 从当前需要冒泡属性的 Fiber 节点开始，检查是否有需要冒泡的属性。
   * 如果当前节点有需要冒泡的属性，将这些属性冒泡到父节点的 subtreeFlags 或其他适当的属性中。
   * 递归调用 bubbleProperties 函数，处理父节点，将属性继续冒泡到更上层的祖先节点，直至达到根节点。
   */
  function bubbleProperties(workInProgress) {
      let subtreeFlags = NoFlags;
      let child = workInProgress.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = workInProgress;
          child = child.sibling;
      }
      workInProgress.subtreeFlags |= subtreeFlags;
  }

  // packages/react-reconciler/src/commitWork.ts
  let nextEffect = null;
  /**
   * 负责深度优先遍历 Fiber 树，递归地向下寻找子节点是否存在 Mutation 阶段需要执行的 flags，
   * 如果遍历到某个节点，其所有子节点都不存在 flags（即 subtreeFlags == NoFlags），
   * 则停止向下，调用 commitMutationEffectsOnFiber 处理该节点的 flags，并且开始遍历其兄弟节点和父节点。
   *
   * commitMutationEffectsOnFiber 会根据每个节点的 flags 和更新计划中的信息执行相应的 DOM 操作。
   *
   * 以 Placement 为例：如果 Fiber 节点的标志中包含 Placement，表示需要在 DOM 中插入新元素，
   * 此时就需要取到该 Fiber 节点对应的 DOM，并将其插入对应的父 DOM 节点中。
   */
  const commitMutationEffects = (finishedWork) => {
      nextEffect = finishedWork;
      // 深度优先遍历 Fiber 树，寻找更新 flags
      while (nextEffect !== null) {
          // 向下遍历
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
              child !== null) {
              // 子节点存在 mutation 阶段需要执行的 flags
              nextEffect = child;
          }
          else {
              // 子节点不存在 mutation 阶段需要执行的 flags 或没有子节点
              // 向上遍历
              up: while (nextEffect !== null) {
                  // 处理 flags
                  commitMutationEffectsOnFiber(nextEffect);
                  const sibling = nextEffect.sibling;
                  // 遍历兄弟节点
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  // 遍历父节点
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  const commitMutationEffectsOnFiber = (finishedWork) => {
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          finishedWork.flags &= -3;
      }
      if ((flags & Update) !== NoFlags) {
          // TODO Update
          finishedWork.flags &= -5;
      }
      if ((flags & ChildDeletion) !== NoFlags) {
          // TODO ChildDeletion
          finishedWork.flags &= -9;
      }
  };
  // 执行 DOM 插入操作，将 FiberNode 对应的 DOM 插入 parent DOM 中
  const commitPlacement = (finishedWork) => {
      {
          console.log('执行 Placement 操作', finishedWork);
      }
      const hostParent = getHostParent(finishedWork);
      if (hostParent !== null) {
          appendPlacementNodeIntoContainer(finishedWork, hostParent);
      }
  };
  // 获取 parent DOM
  const getHostParent = (fiber) => {
      let parent = fiber.return;
      while (parent !== null) {
          const parentTag = parent.tag;
          // 处理 Root 节点
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          // 处理原生 DOM 元素节点
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          else {
              parent = parent.return;
          }
      }
      {
          console.warn('未找到 host parent', fiber);
      }
      return null;
  };
  const appendPlacementNodeIntoContainer = (finishedWork, hostParent) => {
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          appendChildToContainer(finishedWork.stateNode, hostParent);
      }
      else {
          const child = finishedWork.child;
          if (child !== null) {
              appendPlacementNodeIntoContainer(child, hostParent);
              let sibling = child.sibling;
              while (sibling !== null) {
                  appendPlacementNodeIntoContainer(sibling, hostParent);
                  sibling = sibling.sibling;
              }
          }
      }
  };

  // packages/react-reconciler/src/workLoop.ts
  let workInProgress = null;
  function renderRoot(root) {
      // 初始化 workInProgress 变量
      prepareFreshStack(root);
      do {
          try {
              // 深度优先遍历
              workLoop();
              break;
          }
          catch (e) {
              console.warn('workLoop发生错误：', e);
              workInProgress = null;
          }
      } while (true);
      // 创建根 Fiber 树的 Root Fiber
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      // 提交阶段的入口函数
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.log('commit 阶段开始');
      }
      // 重置
      root.finishedWork = null;
      // 判断是否存在 3 个子阶段需要执行的操作
      const subtreeHasEffects = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
      const rootHasEffects = (finishedWork.flags & MutationMask) !== NoFlags;
      if (subtreeHasEffects || rootHasEffects) {
          // TODO: BeforeMutation
          // Mutation
          commitMutationEffects(finishedWork);
          // Fiber 树切换，workInProgress 变成 current
          root.current = finishedWork;
          // TODO: Layout
      }
      else {
          root.current = finishedWork;
      }
  }
  // 初始化 workInProgress 变量
  // 初始化 workInProgress 变量
  function prepareFreshStack(root) {
      workInProgress = createWorkInProgress(root.current, {});
  }
  // 深度优先遍历，向下递归子节点
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      // 比较并返回子 FiberNode
      const next = beginWork(fiber);
      fiber.memorizedPros = fiber.pendingProps;
      if (next == null) {
          // 没有子节点，则遍历兄弟节点或父节点
          completeUnitOfWork(fiber);
      }
      else {
          // 有子节点，继续向下深度遍历
          workInProgress = next;
      }
  }
  // 深度优先遍历，向下递归子节点
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          // 生成更新计划
          completeWork(node);
          // 有兄弟节点，则遍历兄弟节点
          const sibling = node.sibling;
          if (sibling !== null) {
              workInProgress = sibling;
              return;
          }
          // 否则向上返回，遍历父节点
          node = node.return;
          // workInProgress 最终指向根节点
          workInProgress = node;
      } while (node !== null);
  }
  // 调度功能
  function scheduleUpdateOnFiber(fiber) {
      const root = markUpdateFromFiberToRoot(fiber);
      renderRoot(root);
  }
  // 从触发更新的节点向上遍历到 FiberRootNode
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      while (node.return !== null) {
          node = node.return;
      }
      if (node.tag == HostRoot) {
          return node.stateNode;
      }
      return null;
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRootFiber);
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current;
      const update = createUpdate(element);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber);
      return element;
  }

  /**
   * 实现 ReactDOM.createRoot(root).render(<App />);
   * createContainer 函数: 用于创建一个新的容器（container），该容器包含了 React 应用的根节点以及与之相关的一些配置信息。
   * updateContainer 函数: 用于更新已经存在的容器中的内容，将新的 React 元素（element）渲染到容器中，并更新整个应用的状态。
   * @param container
   * @returns
   */
  function createRoot(container) {
      const root = createContainer(container);
      return {
          render(element) {
              updateContainer(element, root);
          }
      };
  }

  var ReactDOM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDOM;

}));
