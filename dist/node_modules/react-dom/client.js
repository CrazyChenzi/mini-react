(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('scheduler')) :
  typeof define === 'function' && define.amd ? define(['scheduler'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory(global.scheduler));
})(this, (function (scheduler) { 'use strict';

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;
  const Fragment = 7;

  const NoFlags = 0b0000000; // 0
  const Placement = 0b0000010; // 2
  const Update = 0b0000100; // 4
  const ChildDeletion = 0b0001000; // 8
  const PassiveEffect = 0b0010000; // 16 Fiber 节点本次更新存在副作用
  const MutationMask = Placement | Update | ChildDeletion;
  // useEffect 的依赖变化时，或函数组件卸载时，执行回调
  const PassiveMask = PassiveEffect | ChildDeletion;

  const NoLane = 0b0000;
  const NoLanes = 0b0000;
  const SyncLane = 0b0001;
  function mergeLanes(laneA, laneB) {
      return laneA | laneB;
  }
  // 获取更新的优先级
  function requestUpdateLanes() {
      return SyncLane;
  }
  // 获取 lanes 中优先级最高的 lane
  function getHighestPriorityLane(lanes) {
      // 默认规则：数值越小，优先级越高
      return lanes & -lanes;
  }
  // 从根节点的 pendingLanes 中移除某个 lane
  function markRootFinished(root, lane) {
      root.pendingLanes &= ~lane;
  }

  class FiberNode {
      tag; // 类型；
      key; // 唯一标识；
      stateNode; // 节点对应的实际 DOM 节点或组件实例；
      type; // 节点的类型，可以是原生 DOM 元素、函数组件或类组件等；
      return; // 指向节点的父节点；
      sibling; // 指向节点的下一个兄弟节点；
      child; // 指向节点的第一个子节点；
      index; // 索引；
      ref; // 指向节点的 ref 属性；
      pendingProps; // 表示节点的新属性，用于在协调过程中进行更新。
      memoizedProps; // 已经更新完的属性
      memoizedState; // 更新完成后新的 State
      alternate; // 指向节点的备份节点，用于在协调过程中进行比较；
      flags; // 表示节点的副作用类型，如更新、插入、删除等；
      deletions;
      subtreeFlags; // 表示子节点的副作用类型，如更新、插入、删除等；
      updateQueue; // 更新计划队列
      constructor(tag, pendingProps, key) {
          // 类型
          this.tag = tag;
          this.key = key || null;
          this.ref = null;
          this.stateNode = null; // 节点对应的实际 DOM 节点或组件实例
          this.type = null; // 节点的类型，可以是原生 DOM 元素、函数组件或类组件等
          // 构成树状结构
          this.return = null; // 指向节点的父节点
          this.sibling = null; // 指向节点的下一个兄弟节点
          this.child = null; // 指向节点的第一个子节点
          this.index = 0; // 索引
          // 作为工作单元
          this.pendingProps = pendingProps; // 表示节点的新属性，用于在协调过程中进行更新
          this.memoizedProps = null; // 已经更新完的属性
          this.memoizedState = null; // 更新完成后新的 State
          this.alternate = null; // 指向节点的备份节点，用于在协调过程中进行比较
          this.flags = NoFlags; // 表示节点的副作用类型，如更新、插入、删除等
          this.subtreeFlags = NoFlags; // 表示子节点的副作用类型，如更新、插入、删除等
          this.updateQueue = null; // 更新计划队列
          this.deletions = null; // 指向待删除的子节点，用于在协调过程中进行删除
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      pendingLanes; // 表示当前正在处理的更新的调度
      finishedLane; // 表示已经完成的更新的调度
      pendingPassiveEffects;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          // 将根节点的 stateNode 属性指向 FiberRootNode，用于表示整个 React 应用的根节点
          hostRootFiber.stateNode = this;
          // 指向更新完成之后的 hostRootFiber
          this.finishedWork = null;
          this.pendingLanes = NoLanes;
          this.finishedLane = NoLane;
          this.pendingPassiveEffects = {
              unmount: [],
              update: []
          };
      }
  }
  // 根据 FiberRootNode.current 创建 workInProgress
  const createWorkInProgress = (current, pendingProps) => {
      let workInProgress = current.alternate;
      if (workInProgress == null) {
          // 首屏渲染时（mount）
          workInProgress = new FiberNode(current.tag, pendingProps, current.key);
          workInProgress.stateNode = current.stateNode;
          // 双缓冲机制
          workInProgress.alternate = current;
          current.alternate = workInProgress;
      }
      else {
          // 非首屏渲染时（update）
          workInProgress.pendingProps = pendingProps;
          // 将 effect 链表重置为空，以便在更新过程中记录新的副作用
          workInProgress.flags = NoFlags;
      }
      // 复制当前节点的大部分属性
      workInProgress.type = current.type;
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      return workInProgress;
  };
  // 根据 DOM 节点创建新的 Fiber 节点
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type == 'string') {
          // 如: <div/> 的 type: 'div'
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function' && true) {
          console.warn('未定义的 type 类型', element);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }
  function createFiberFromFragment(elements, key) {
      const fiber = new FiberNode(Fragment, elements, key);
      return fiber;
  }

  // 创建 Update 实例的方法
  const createUpdate = (action, lane) => {
      return {
          action,
          next: null,
          lane
      };
  };
  // 创建 UpdateQueue 实例的方法
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null
          },
          dispatch: null
      };
  };
  // 将 Update 添加到 UpdateQueue 中的方法
  const enqueueUpdate = (updateQueue, update) => {
      const pending = updateQueue.shared.pending;
      if (pending === null) {
          update.next = update;
      }
      else {
          update.next = pending.next;
          pending.next = update;
      }
      // pending 指向 update 环状链表的最后一个节点
      updateQueue.shared.pending = update;
  };
  // 从 UpdateQueue 中消费 Update 的方法
  const processUpdateQueue = (baseState, pendingUpdate, renderLane) => {
      const result = {
          memoizedState: baseState
      };
      if (pendingUpdate !== null) {
          // 第一个 update
          const first = pendingUpdate.next;
          let pending = first;
          do {
              const updateLane = pending.lane;
              if (updateLane == renderLane) {
                  const action = pending.action;
                  if (action instanceof Function) {
                      // 若 action 是回调函数：(baseState = 1, update = (i) => 5i)) => memoizedState = 5
                      baseState = action(baseState);
                  }
                  else {
                      // 若 action 是状态值：(baseState = 1, update = 2) => memoizedState = 2
                      baseState = action;
                  }
              }
              else {
                  {
                      console.error('不应该进入 updateLane !== renderLane 逻辑');
                  }
              }
              pending = pending.next;
          } while (pending !== first);
      }
      result.memoizedState = baseState;
      return result;
  };

  // packages/shared/ReactSymbols.ts
  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  // 表示普通的 React 元素，即通过 JSX 创建的组件或 DOM 元素
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7;
  // 表示 Fragment 组件，即 <React.Fragment> 或短语法 <></> 创建的 Fragment
  const REACT_FRAGMENT_TYPE = supportSymbol
      ? Symbol.for('react.fragment')
      : 0xeacb;

  function ChildReconciler(shouldTrackSideEffects) {
      // 从父节点中删除指定的子节点
      function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
              return;
          }
          const deletions = returnFiber.deletions;
          if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
          }
          else {
              deletions.push(childToDelete);
          }
      }
      // 删除当前节点的所有兄弟节点
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects)
              return;
          let childToDelete = currentFirstChild;
          while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
          }
      }
      // 复用 Fiber 节点
      function useFiber(fiber, pendingProps) {
          const clone = createWorkInProgress(fiber, pendingProps);
          clone.index = 0;
          clone.sibling = null;
          return clone;
      }
      // 处理单个 Element 节点的情况
      // 对比 currentFiber 与 ReactElement，生成 workInProgress FiberNode
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          // 组件的更新阶段
          while (currentFiber !== null) {
              if (currentFiber !== null) {
                  if (currentFiber.key === element.key) {
                      if (element.$$typeof === REACT_ELEMENT_TYPE) {
                          if (currentFiber.type === element.type) {
                              // key 和 type 都相同，复用旧的 Fiber 节点
                              // 处理 Fragment 的情况
                              let props = element.props;
                              if (element.type === REACT_FRAGMENT_TYPE) {
                                  props = element.props.children;
                              }
                              const existing = useFiber(currentFiber, props);
                              existing.return = returnFiber;
                              // 剩下的兄弟节点标记删除
                              deleteRemainingChildren(returnFiber, currentFiber.sibling);
                              return existing;
                          }
                          // key 相同，但 type 不同，删除旧的 Fiber 节点
                          deleteRemainingChildren(returnFiber, currentFiber);
                          break;
                      }
                      else {
                          {
                              console.warn('还未实现的 React 类型', element);
                          }
                      }
                  }
                  else {
                      // key 不同，删除当前旧的 Fiber 节点，继续遍历兄弟节点
                      deleteChild(returnFiber, currentFiber);
                      currentFiber = currentFiber.sibling;
                  }
              }
          }
          // 创建新的 Fiber 节点
          // 创建新的 Fiber 节点
          let fiber;
          if (element.type === REACT_FRAGMENT_TYPE) {
              fiber = createFiberFromFragment(element.props.children, element.key);
          }
          else {
              fiber = createFiberFromElement(element);
          }
          fiber.return = returnFiber;
          return fiber;
      }
      // 处理文本节点的情况
      // 对比 currentFiber 与 ReactElement，生成 workInProgress FiberNode
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          while (currentFiber !== null) {
              // 组件的更新阶段
              if (currentFiber.tag === HostText) {
                  // 复用旧的 Fiber 节点
                  const existing = useFiber(currentFiber, { content });
                  existing.return = returnFiber;
                  deleteRemainingChildren(returnFiber, currentFiber.sibling);
                  return existing;
              }
              else {
                  // 删除旧的 Fiber 节点
                  deleteChild(returnFiber, currentFiber);
                  currentFiber = currentFiber.sibling;
              }
          }
          // 创建新的 Fiber 节点
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          // 首屏渲染且追踪副作用时，才添加标记
          if (shouldTrackSideEffects && fiber.alternate == null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
          // 最后一个可复用 Fiber 在 current 中的 index
          let lastPlacedIndex = 0;
          // 创建的第一个新 Fiber
          let firstNewFiber = null;
          // 创建的最后一个新 Fiber
          let lastNewFiber = null;
          // 1. 将 current 中所有同级 Fiber 节点保存在 Map 中
          const existingChildren = new Map();
          let current = currentFirstChild;
          while (current !== null) {
              const keyToUse = current.key !== null ? current.key : current.index.toString();
              existingChildren.set(keyToUse, current);
              current = current.sibling;
          }
          // 2. 遍历 newChild 数组，判断是否可复用
          for (let i = 0; i < newChild.length; i++) {
              const after = newChild[i];
              const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
              if (newFiber == null) {
                  continue;
              }
              // 3. 标记插入或移动
              newFiber.index = i;
              newFiber.return = returnFiber;
              if (lastNewFiber == null) {
                  lastNewFiber = newFiber;
                  firstNewFiber = newFiber;
              }
              else {
                  lastNewFiber.sibling = newFiber;
                  lastNewFiber = lastNewFiber.sibling;
              }
              if (!shouldTrackSideEffects) {
                  continue;
              }
              const current = newFiber.alternate;
              if (current !== null) {
                  const oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                      // 标记移动
                      newFiber.flags |= Placement;
                      continue;
                  }
                  else {
                      // 不移动
                      lastPlacedIndex = oldIndex;
                  }
              }
              else {
                  // 首屏渲染阶段，标记插入
                  newFiber.flags |= Placement;
              }
          }
          // 4. 将 Map 中剩下的标记为删除
          existingChildren.forEach((fiber) => {
              deleteChild(returnFiber, fiber);
          });
          return firstNewFiber;
      }
      function updateFromMap(returnFiber, existingChildren, index, element) {
          const keyToUse = element.key !== null ? element.key : index.toString();
          const before = existingChildren.get(keyToUse);
          // HostText
          if (typeof element === 'string' || typeof element === 'number') {
              // 可复用，复用旧的 Fiber 节点
              if (before && before.tag === HostText) {
                  existingChildren.delete(keyToUse);
                  return useFiber(before, { content: element + '' });
              }
              // 不可复用，创建新的 Fiber 节点
              return new FiberNode(HostText, { content: element + '' }, null);
          }
          // HostComponent
          if (typeof element === 'object' && element !== null) {
              switch (element.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      if (element.type === REACT_FRAGMENT_TYPE) {
                          return updateFragment(returnFiber, before, element, keyToUse, existingChildren);
                      }
                      // 可复用，复用旧的 Fiber 节点
                      if (before && before.type === element.type) {
                          existingChildren.delete(keyToUse);
                          return useFiber(before, element.props);
                      }
                      // 不可复用，创建新的 Fiber 节点
                      return createFiberFromElement(element);
              }
          }
          // 数组类型的 ReactElement，如：<ul>{[<li/>, <li/>]}</ul>
          if (Array.isArray(element)) {
              return updateFragment(returnFiber, before, element, keyToUse, existingChildren);
          }
          return null;
      }
      // 闭包，根绝 shouldTrackSideEffects 返回不同 reconcileChildFibers 的实现
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断 Fragment
          const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
              newChild !== null &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
          }
          // 判断当前 fiber 的类型
          // 判断 ReactElement 节点
          if (typeof newChild == 'object' && newChild !== null) {
              // 处理多个 ReactElement 节点的情况
              if (Array.isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFiber, newChild);
              }
              // 处理单个 ReactElement 节点的情况
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('未实现的 reconcile 类型', newChild);
                      }
                      break;
              }
          }
          // 文本节点
          if (typeof newChild == 'string' || typeof newChild == 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          // default 情况，删除旧的 Fiber 节点
          if (currentFiber !== null) {
              deleteRemainingChildren(returnFiber, currentFiber);
          }
          {
              console.warn('未实现的 reconcile 类型', newChild);
          }
          return null;
      };
      // 复用或新建 Fragment
      function updateFragment(returnFiber, current, elements, key, existingChildren) {
          let fiber;
          if (!current || current.tag !== Fragment) {
              fiber = createFiberFromFragment(elements, key);
          }
          else {
              existingChildren.delete(key);
              fiber = useFiber(current, elements);
          }
          fiber.return = returnFiber;
          return fiber;
      }
  }
  // 组件的更新阶段中，追踪副作用
  const reconcileChildFibers = ChildReconciler(true);
  // 首屏渲染阶段中不追踪副作用，只对根节点执行一次 DOM 插入操作
  const mountChildFibers = ChildReconciler(false);

  const currentDispatcher$1 = {
      current: null
  };

  // React
  // 内部数据共享层
  const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
      currentDispatcher: currentDispatcher$1
  };

  // packages/shared/internals.ts
  // 为了将 react-reconciler 和 react 解耦，在 shared 中转，方便 react-reconciler 使用
  const internals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  // Fiber 节点本次更新存在副作用
  const HookHasEffect = 0b0001;
  const Passive = 0b0010; // useEffect

  /* eslint-disable @typescript-eslint/no-explicit-any */
  // 当前正在处理的 FiberNode
  let currentlyRenderingFiber = null;
  // Hooks 链表中当前正在处理的 Hook
  let workInProgressHook = null;
  let currentHook = null;
  let renderLane = NoLane;
  const { currentDispatcher } = internals;
  // 执行函数组件中的函数
  function renderWithHooks(workInProgress, lane) {
      // 赋值
      currentlyRenderingFiber = workInProgress;
      renderLane = lane;
      // 重置 Hooks 链表
      workInProgress.memoizedState = null;
      // 重置 Effect 链表
      workInProgress.updateQueue = null;
      // 判断 Hooks 被调用的时机
      const current = workInProgress.alternate;
      {
          console.warn(current !== null ? '组件的更新阶段' : '首屏渲染阶段');
      }
      if (current !== null) {
          // 组件的更新阶段(update)
          currentDispatcher.current = HooksDispatcherOnUpdate;
      }
      else {
          // 首屏渲染阶段(mount)
          currentDispatcher.current = HooksDispatcherOnMount;
      }
      // 函数保存在 type 字段中
      const Component = workInProgress.type;
      const props = workInProgress.pendingProps;
      // 执行函数
      const children = Component(props);
      // 重置
      currentlyRenderingFiber = null;
      workInProgressHook = null;
      currentHook = null;
      renderLane = NoLane;
      return children;
  }
  const HooksDispatcherOnMount = {
      useState: mountState,
      useEffect: mountEffect
  };
  const HooksDispatcherOnUpdate = {
      useState: updateState,
      useEffect: updateEffect
  };
  function mountState(initialState) {
      {
          console.warn('调用 mountState 方法');
      }
      // 当前正在工作的 useState
      const hook = mountWorkInProgressHook();
      // 获取当前 useState 对应的 Hook 数据
      let memoizedState;
      if (initialState instanceof Function) {
          memoizedState = initialState();
      }
      else {
          memoizedState = initialState;
      }
      hook.memoizedState = memoizedState;
      const queue = createUpdateQueue();
      hook.queue = queue;
      // @ts-ignore
      // 实现 dispatch
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [memoizedState, dispatch];
  }
  function updateState() {
      {
          console.warn('updateState 开始');
      }
      // 当前正在工作的 useState
      const hook = updateWorkInProgressHook();
      // 计算新 state 的逻辑
      const queue = hook.queue;
      const pending = queue.shared.pending;
      queue.shared.pending = null;
      if (pending !== null) {
          const { memoizedState } = processUpdateQueue(hook.memoizedState, pending, renderLane);
          hook.memoizedState = memoizedState;
      }
      return [hook.memoizedState, queue.dispatch];
  }
  function mountEffect(create, deps) {
      // 当前正在工作的 useEffect
      const hook = mountWorkInProgressHook();
      const nextDeps = deps == undefined ? null : deps;
      currentlyRenderingFiber.flags |= PassiveEffect;
      hook.memoizedState = pushEffect(Passive | HookHasEffect, create, undefined, nextDeps);
  }
  function updateEffect(create, deps) {
      // 当前正在工作的 useEffect
      const hook = updateWorkInProgressHook();
      const nextDeps = deps == undefined ? null : deps;
      let destroy;
      if (currentHook !== null) {
          const prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
              // 浅比较依赖
              const prevDeps = prevEffect.deps;
              // 浅比较，相等
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(Passive, create, destroy, nextDeps);
                  return;
              }
              // 浅比较，不相等
              currentlyRenderingFiber.flags |= PassiveEffect;
              hook.memoizedState = pushEffect(Passive | HookHasEffect, create, destroy, nextDeps);
          }
      }
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
      if (nextDeps === null || prevDeps === null)
          return false;
      for (let i = 0; i < nextDeps.length && i < prevDeps.length; i++) {
          if (Object.is(nextDeps[i], prevDeps[i])) {
              continue;
          }
          return false;
      }
      return true;
  }
  function pushEffect(tag, create, destroy, deps) {
      const effect = {
          tag,
          create,
          destroy,
          deps,
          next: null
      };
      const fiber = currentlyRenderingFiber;
      const updateQueue = fiber.updateQueue;
      if (updateQueue === null) {
          const newUpdateQueue = creactFCUpdateQueue();
          effect.next = effect;
          newUpdateQueue.lastEffect = effect;
          fiber.updateQueue = newUpdateQueue;
      }
      else {
          const lastEffect = updateQueue.lastEffect;
          if (lastEffect == null) {
              effect.next = effect;
              updateQueue.lastEffect = effect;
          }
          else {
              const firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              updateQueue.lastEffect = effect;
          }
      }
      return effect;
  }
  function creactFCUpdateQueue() {
      const updateQueue = createUpdateQueue();
      updateQueue.lastEffect = null;
      return updateQueue;
  }
  function updateWorkInProgressHook() {
      // TODO render 阶段触发的更新
      // 保存链表中的下一个 Hook
      let nextCurrentHook;
      if (currentHook == null) {
          // 这是函数组件 update 时的第一个 hook
          const current = currentlyRenderingFiber.alternate;
          if (current === null) {
              nextCurrentHook = null;
          }
          else {
              nextCurrentHook = current.memoizedState;
          }
      }
      else {
          // 这是函数组件 update 时后续的 hook
          nextCurrentHook = currentHook.next;
      }
      if (nextCurrentHook == null) {
          throw new Error(`组件 ${currentlyRenderingFiber?.type} 本次执行时的 Hooks 比上次执行多`);
      }
      currentHook = nextCurrentHook;
      const newHook = {
          memoizedState: currentHook.memoizedState,
          queue: currentHook.queue,
          next: null
      };
      if (workInProgressHook == null) {
          // update 时的第一个hook
          if (currentlyRenderingFiber !== null) {
              workInProgressHook = newHook;
              currentlyRenderingFiber.memoizedState = workInProgressHook;
          }
          else {
              // currentlyRenderingFiber == null 代表 Hook 执行的上下文不是一个函数组件
              throw new Error('Hooks 只能在函数组件中执行');
          }
      }
      else {
          // update 时的其他 hook
          // 将当前处理的 Hook.next 指向新建的 hook，形成 Hooks 链表
          workInProgressHook.next = newHook;
          // 更新当前处理的 Hook
          workInProgressHook = newHook;
      }
      return workInProgressHook;
  }
  function mountWorkInProgressHook() {
      const hook = {
          memoizedState: null,
          queue: null,
          next: null
      };
      if (workInProgressHook == null) {
          // mount 时的第一个hook
          if (currentlyRenderingFiber !== null) {
              workInProgressHook = hook;
              currentlyRenderingFiber.memoizedState = workInProgressHook;
          }
          else {
              // currentlyRenderingFiber == null 代表 Hook 执行的上下文不是一个函数组件
              throw new Error('Hooks 只能在函数组件中执行');
          }
      }
      else {
          // mount 时的其他 hook
          // 将当前处理的 Hook.next 指向新建的 hook，形成 Hooks 链表
          workInProgressHook.next = hook;
          // 更新当前处理的 Hook
          workInProgressHook = hook;
      }
      return workInProgressHook;
  }
  // 用于触发状态更新的逻辑
  function dispatchSetState(fiber, updateQueue, action) {
      const lane = requestUpdateLanes();
      const update = createUpdate(action, lane);
      enqueueUpdate(updateQueue, update);
      // 调度更新
      scheduleUpdateOnFiber(fiber, lane);
  }

  // 比较并返回子 FiberNode
  const beginWork = (workInProgress, renderLane) => {
      switch (workInProgress.tag) {
          case HostRoot: // 根节点
              return updateHostRoot(workInProgress, renderLane);
          case HostComponent: // 原生 DOM 元素节点，例如 <div>、<span> 等
              return updateHostComponent$1(workInProgress);
          case HostText: // 文本节点
              return updateHostText$1();
          case FunctionComponent: // 函数组件
              return updateFunctionComponent(workInProgress, renderLane);
          case Fragment:
              return updateFragment(workInProgress);
          default:
              {
                  console.warn('beginWork 未实现的类型', workInProgress.tag);
              }
              break;
      }
  };
  function updateHostRoot(workInProgress, renderLane) {
      // 根据当前节点和工作中节点的状态进行比较，处理属性等更新逻辑
      const baseState = workInProgress.memoizedState;
      const updateQueue = workInProgress.updateQueue;
      const pending = updateQueue.shared.pending;
      // 清空更新链表
      updateQueue.shared.pending = null;
      // 计算待更新状态的最新值
      const { memoizedState } = processUpdateQueue(baseState, pending, renderLane);
      workInProgress.memoizedState = memoizedState;
      // 处理子节点的更新逻辑
      const nextChildren = workInProgress.memoizedState;
      reconcileChildren(workInProgress, nextChildren);
      // 返回新的子节点
      return workInProgress.child;
  }
  function updateHostComponent$1(workInProgress) {
      const nextProps = workInProgress.pendingProps;
      const nextChildren = nextProps.children;
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  function updateHostText$1() {
      // 没有子节点，直接返回 null
      return null;
  }
  function updateFunctionComponent(workInProgress, renderLane) {
      const nextChildren = renderWithHooks(workInProgress, renderLane);
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  function updateFragment(workInProgress) {
      const nextChildren = workInProgress.pendingProps;
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  /**
   * 通过对比子节点的 current FiberNode 与 子节点的 ReactElement，
   * 来生成子节点对应的 workInProgress FiberNode。
   * （current 是与视图中真实 UI 对应的 Fiber 树，workInProgress 是触发更新后正在 Reconciler 中计算的 Fiber 树。）
   */
  function reconcileChildren(workInProgress, children) {
      // alternate 指向节点的备份节点，即 current
      const current = workInProgress.alternate;
      if (current !== null) {
          // 组件的更新阶段
          workInProgress.child = reconcileChildFibers(workInProgress, current?.child, children);
      }
      else {
          // 首屏渲染阶段
          workInProgress.child = mountChildFibers(workInProgress, null, children);
      }
  }

  const elementPropsKey = '__props';
  const validEventTypeList = ['click'];
  // 将事件的回调保存在 DOM 中
  function updateFiberProps(node, props) {
      node[elementPropsKey] = props;
  }
  function initEvent(container, eventType) {
      if (!validEventTypeList.includes(eventType)) {
          console.warn('initEvent 未实现的事件类型', eventType);
          return;
      }
      {
          console.log('初始化事件', eventType);
      }
      container.addEventListener(eventType, (e) => {
          dispatchEvent(container, eventType, e);
      });
  }
  function dispatchEvent(container, eventType, e) {
      const targetElement = e.target;
      if (targetElement == null) {
          console.warn('事件不存在targetElement', e);
          return;
      }
      // 收集沿途事件
      const { bubble, capture } = collectPaths(targetElement, container, eventType);
      // 构造合成事件
      const syntheticEvent = createSyntheticEvent(e);
      // 遍历捕获 capture
      triggerEventFlow(capture, syntheticEvent);
      // 遍历冒泡 bubble
      if (!syntheticEvent.__stopPropagation) {
          triggerEventFlow(bubble, syntheticEvent);
      }
  }
  function collectPaths(targetElement, container, eventType) {
      const paths = {
          capture: [],
          bubble: []
      };
      // 收集
      while (targetElement && targetElement !== container) {
          const elementProps = targetElement[elementPropsKey];
          if (elementProps) {
              const callbackNameList = getEventCallbackNameFromEventType(eventType);
              {
                  callbackNameList.forEach((callbackName, i) => {
                      const callback = elementProps[callbackName];
                      if (callback) {
                          if (i == 0) {
                              paths.capture.unshift(callback);
                          }
                          else {
                              paths.bubble.push(callback);
                          }
                      }
                  });
              }
          }
          targetElement = targetElement.parentNode;
      }
      return paths;
  }
  function getEventCallbackNameFromEventType(eventType) {
      return {
          click: ['onClickCapture', 'onClick']
      }[eventType];
  }
  function createSyntheticEvent(e) {
      const syntheticEvent = e;
      syntheticEvent.__stopPropagation = false;
      const originStopPropagation = e.stopPropagation;
      syntheticEvent.stopPropagation = () => {
          syntheticEvent.__stopPropagation = true;
          if (originStopPropagation) {
              originStopPropagation();
          }
      };
      return syntheticEvent;
  }
  function triggerEventFlow(paths, syntheticEvent) {
      for (let i = 0; i < paths.length; i++) {
          const callback = paths[i];
          callback.call(null, syntheticEvent);
          if (syntheticEvent.__stopPropagation) {
              break;
          }
      }
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  const createInstance = (type, porps) => {
      const element = document.createElement(type);
      updateFiberProps(element, porps);
      return element;
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child);
  };
  const insertChildToContainer = (child, container, before) => {
      container.insertBefore(child, before);
  };
  const createTextInstance = (content) => {
      const element = document.createTextNode(content);
      return element;
  };
  const appendChildToContainer = (child, parent) => {
      parent.appendChild(child);
  };
  const commitUpdate = (fiber) => {
      {
          console.log('执行 Update 操作', fiber);
      }
      switch (fiber.tag) {
          case HostComponent:
              return updateFiberProps(fiber.stateNode, fiber.memoizedProps);
          case HostText:
              const text = fiber.memoizedProps.content;
              commitTextUpdate(fiber.stateNode, text);
              break;
          default:
              {
                  console.warn('未实现的 commitUpdate 类型', fiber);
              }
      }
  };
  const commitTextUpdate = (textInstance, content) => {
      textInstance.textContent = content;
  };
  const removeChild = (child, container) => {
      container.removeChild(child);
  };
  const scheduleMicroTask = typeof queueMicrotask === 'function'
      ? queueMicrotask
      : typeof Promise === 'function'
          ? (callback) => Promise.resolve(null).then(callback)
          : setTimeout;

  // packages/react-reconciler/src/completeWork.ts
  // 生成更新计划，计算和收集更新 flags
  const completeWork = (workInProgress) => {
      const newProps = workInProgress.pendingProps;
      const current = workInProgress.alternate;
      switch (workInProgress.tag) {
          case HostRoot:
          case FunctionComponent:
          case Fragment:
              bubbleProperties(workInProgress);
              return null;
          case HostComponent:
              if (current !== null && workInProgress.stateNode !== null) {
                  // 组件的更新阶段
                  updateHostComponent(current, workInProgress);
              }
              else {
                  // 首屏渲染阶段
                  // 构建 DOM
                  const instance = createInstance(workInProgress.type, newProps);
                  // 将 DOM 插入到 DOM 树中
                  appendAllChildren(instance, workInProgress);
                  workInProgress.stateNode = instance;
              }
              // 收集更新 flags
              bubbleProperties(workInProgress);
              return null;
          case HostText:
              if (current !== null && workInProgress.stateNode !== null) {
                  // 组件的更新阶段
                  updateHostText(current, workInProgress);
              }
              else {
                  // 首屏渲染阶段
                  // 构建 DOM
                  const instance = createTextInstance(newProps.content);
                  workInProgress.stateNode = instance;
              }
              // 收集更新 flags
              bubbleProperties(workInProgress);
              return null;
          default:
              {
                  console.warn('completeWork 未实现的类型', workInProgress);
              }
              return null;
      }
  };
  function updateHostText(current, workInProgress) {
      const oldText = current.memoizedProps.content;
      const newText = workInProgress.pendingProps.content;
      if (oldText !== newText) {
          markUpdate(workInProgress);
      }
  }
  function updateHostComponent(current, workInProgress) {
      const oldProps = current.memoizedProps;
      const newProps = workInProgress.pendingProps;
      if (oldProps !== newProps) {
          markUpdate(workInProgress);
      }
      updateFiberProps(workInProgress.stateNode, newProps);
  }
  // 为 Fiber 节点增加 Update flags
  function markUpdate(workInProgress) {
      workInProgress.flags |= Update;
  }
  /**
   * 负责递归地将组件的子节点添加到指定的 parent 中，
   * 它通过深度优先遍历 workInProgress 的子节点链表，处理每个子节点的类型。
   * 先处理当前节点的所有子节点，再处理兄弟节点。
   *
   * 如果它是原生 DOM 元素节点或文本节点，则将其添加到父节点中；如果是其他类型的组件节点并且有子节点，则递归处理其子节点。
   */
  function appendAllChildren(parent, workInProgress) {
      let node = workInProgress.child;
      while (node !== null) {
          if (node.tag == HostComponent || node.tag == HostText) {
              // 处理原生 DOM 元素节点或文本节点
              appendInitialChild(parent, node.stateNode);
          }
          else if (node.child !== null) {
              // 递归处理其他类型的组件节点的子节点
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node == workInProgress) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                  return;
              }
              node = node.return;
          }
          // 处理下一个兄弟节点
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  /**
   * 负责在 completeWork 函数向上遍历的过程中，通过向上冒泡子节点的 flags，将所有更新 flags 收集到根节点。
   * 从当前需要冒泡属性的 Fiber 节点开始，检查是否有需要冒泡的属性。
   * 如果当前节点有需要冒泡的属性，将这些属性冒泡到父节点的 subtreeFlags 或其他适当的属性中。
   * 递归调用 bubbleProperties 函数，处理父节点，将属性继续冒泡到更上层的祖先节点，直至达到根节点。
   */
  function bubbleProperties(workInProgress) {
      let subtreeFlags = NoFlags;
      let child = workInProgress.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = workInProgress;
          child = child.sibling;
      }
      workInProgress.subtreeFlags |= subtreeFlags;
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  // packages/react-reconciler/src/commitWork.ts
  let nextEffect = null;
  /**
   * 负责深度优先遍历 Fiber 树，递归地向下寻找子节点是否存在 Mutation 阶段需要执行的 flags，
   * 如果遍历到某个节点，其所有子节点都不存在 flags（即 subtreeFlags == NoFlags），
   * 则停止向下，调用 commitMutationEffectsOnFiber 处理该节点的 flags，并且开始遍历其兄弟节点和父节点。
   *
   * commitMutationEffectsOnFiber 会根据每个节点的 flags 和更新计划中的信息执行相应的 DOM 操作。
   *
   * 以 Placement 为例：如果 Fiber 节点的标志中包含 Placement，表示需要在 DOM 中插入新元素，
   * 此时就需要取到该 Fiber 节点对应的 DOM，并将其插入对应的父 DOM 节点中。
   */
  const commitMutationEffects = (finishedWork, root) => {
      nextEffect = finishedWork;
      // 深度优先遍历 Fiber 树，寻找更新 flags
      while (nextEffect !== null) {
          // 向下遍历
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags &&
              child !== null) {
              // 子节点存在 mutation 阶段需要执行的 flags
              nextEffect = child;
          }
          else {
              // 子节点不存在 mutation 阶段需要执行的 flags 或没有子节点
              // 向上遍历
              up: while (nextEffect !== null) {
                  // 处理 flags
                  commitMutationEffectsOnFiber(nextEffect, root);
                  const sibling = nextEffect.sibling;
                  // 遍历兄弟节点
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  // 遍历父节点
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  const commitMutationEffectsOnFiber = (finishedWork, root) => {
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          // 处理完之后，从 flags 中删除 Placement 标记
          finishedWork.flags &= -3;
      }
      if ((flags & Update) !== NoFlags) {
          commitUpdate(finishedWork);
          finishedWork.flags &= -5;
      }
      if ((flags & ChildDeletion) !== NoFlags) {
          const deletions = finishedWork.deletions;
          if (deletions !== null) {
              deletions.forEach((childToDelete) => {
                  commitDeletion(childToDelete, root);
              });
          }
          finishedWork.flags &= -9;
      }
      if ((flags & PassiveEffect) !== NoFlags) {
          // 收集回调
          commitPassiveEffect(finishedWork, root, 'update');
          finishedWork.flags &= -17;
      }
  };
  // 执行 DOM 插入操作，将 FiberNode 对应的 DOM 插入 parent DOM 中
  const commitPlacement = (finishedWork) => {
      {
          console.log('执行 Placement 操作', finishedWork);
      }
      // parent DOM
      const hostParent = getHostParent(finishedWork);
      // Host sibling
      const sibling = getHostSibling(finishedWork);
      appendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
  };
  // 获取兄弟 Host 节点
  const getHostSibling = (fiber) => {
      let node = fiber;
      findSibling: while (true) {
          // 没有兄弟节点时，向上遍历
          while (node.sibling == null) {
              const parent = node.return;
              if (parent == null ||
                  parent.tag == HostComponent ||
                  parent.tag == HostRoot) {
                  return null;
              }
              node = parent;
          }
          // 向下遍历
          node.sibling.return = node.return;
          node = node.sibling;
          while (node.tag !== HostText && node.tag !== HostComponent) {
              // 不稳定的 Host 节点不能作为目标兄弟 Host 节点
              if ((node.flags & Placement) !== NoFlags) {
                  continue findSibling;
              }
              if (node.child == null) {
                  continue findSibling;
              }
              else {
                  node.child.return = node;
                  node = node.child;
              }
          }
          if ((node.flags & Placement) == NoFlags) {
              return node.stateNode;
          }
      }
  };
  // 获取 parent DOM
  const getHostParent = (fiber) => {
      let parent = fiber.return;
      while (parent !== null) {
          const parentTag = parent.tag;
          // 处理 Root 节点
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          // 处理原生 DOM 元素节点
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          parent = parent.return;
      }
      {
          console.warn('未找到 host parent', fiber);
      }
      return null;
  };
  // 删除节点及其子树
  const commitDeletion = (childToDelete, root) => {
      {
          console.log('执行 Deletion 操作', childToDelete);
      }
      // 跟踪需要移除的子树中的 Fiber 节点
      const rootChildrenToDelete = [];
      // 递归遍历子树
      commitNestedUnmounts(childToDelete, (unmountFiber) => {
          switch (unmountFiber.tag) {
              case HostComponent:
                  recordChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  // TODO 解绑ref
                  return;
              case HostText:
                  recordChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case FunctionComponent:
                  commitPassiveEffect(unmountFiber, root, 'unmount');
                  return;
              default:
                  {
                      console.warn('未实现的 delete 类型', unmountFiber);
                  }
          }
      });
      // 移除 rootChildrenToDelete 的DOM
      if (rootChildrenToDelete.length !== 0) {
          // 找到待删除子树的根节点的 parent DOM
          const hostParent = getHostParent(childToDelete);
          rootChildrenToDelete.forEach((node) => {
              removeChild(node.stateNode, hostParent);
          });
      }
      childToDelete.return = null;
      childToDelete.child = null;
  };
  // 深度优先遍历 Fiber 树，执行 onCommitUnmount
  const commitNestedUnmounts = (root, onCommitUnmount) => {
      let node = root;
      while (true) {
          onCommitUnmount(node);
          // 向下遍历，递
          if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          // 终止条件
          if (node === root)
              return;
          // 向上遍历，归
          while (node.sibling === null) {
              // 终止条件
              if (node.return == null || node.return == root)
                  return;
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  };
  const appendPlacementNodeIntoContainer = (finishedWork, hostParent, before) => {
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          if (before) {
              // 执行移动操作
              insertChildToContainer(finishedWork.stateNode, hostParent, before);
          }
          else {
              // 执行插入操作
              appendChildToContainer(finishedWork.stateNode, hostParent);
          }
      }
      else {
          const child = finishedWork.child;
          if (child !== null) {
              appendPlacementNodeIntoContainer(child, hostParent);
              let sibling = child.sibling;
              while (sibling !== null) {
                  appendPlacementNodeIntoContainer(sibling, hostParent);
                  sibling = sibling.sibling;
              }
          }
      }
  };
  function recordChildrenToDelete(childrenToDelete, unmountFiber) {
      const lastOne = childrenToDelete[childrenToDelete.length - 1];
      if (!lastOne) {
          childrenToDelete.push(unmountFiber);
      }
      else {
          let node = lastOne.sibling;
          while (node !== null) {
              if (unmountFiber == node) {
                  childrenToDelete.push(unmountFiber);
              }
              node = node.sibling;
          }
      }
  }
  const commitPassiveEffect = (fiber, root, type) => {
      if (fiber.tag !== FunctionComponent ||
          (type == 'update' && (fiber.flags & PassiveEffect) == NoFlags)) {
          return;
      }
      const updateQueue = fiber.updateQueue;
      if (updateQueue !== null) {
          if (updateQueue.lastEffect == null && true) {
              console.error('commitPassiveEffect: updateQueue.lastEffect is null');
          }
          else {
              root.pendingPassiveEffects[type].push(updateQueue.lastEffect);
          }
      }
  };
  const commitHookEffectList = (tags, lastEffect, callback) => {
      let effect = lastEffect.next;
      do {
          if ((effect.tag & tags) === tags) {
              callback(effect);
          }
          effect = effect.next;
      } while (effect !== lastEffect.next);
  };
  // 组件卸载时，触发所有 unmount destroy
  function commitHookEffectListUnmount(tags, lastEffect) {
      commitHookEffectList(tags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
          effect.tag &= -2;
      });
  }
  // 组件卸载时，触发所有上次更新的 destroy
  function commitHookEffectListDestory(tags, lastEffect) {
      commitHookEffectList(tags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
      });
  }
  // 组件卸载时，触发所有这次更新的 create
  function commitHookEffectListCreate(tags, lastEffect) {
      commitHookEffectList(tags, lastEffect, (effect) => {
          const create = effect.create;
          if (typeof create === 'function') {
              effect.destroy = create();
          }
      });
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  // 同步的任务队列
  let syncQueue = null;
  let isFlushingSyncQueue = false;
  // 调度同步的回调函数
  function scheduleSyncCallback(callback) {
      if (syncQueue === null) {
          syncQueue = [callback];
      }
      syncQueue.push(callback);
  }
  // 遍历执行同步的回调函数
  function flushSyncCallback() {
      if (!isFlushingSyncQueue && syncQueue) {
          isFlushingSyncQueue = true;
          try {
              syncQueue.forEach((callback) => callback());
          }
          catch (e) {
              {
                  console.error('flushSyncCallback 报错', e);
              }
          }
          finally {
              isFlushingSyncQueue = false;
              syncQueue = null;
          }
      }
  }

  // packages/react-reconciler/src/workLoop.ts
  let workInProgress = null;
  let workInProgressRenderLane = NoLane;
  let rootDoesHasPassiveEffects = false;
  // 将更新的优先级(lane)记录到根节点上
  function markRootUpdated(root, lane) {
      root.pendingLanes = mergeLanes(root.pendingLanes, lane);
  }
  // Schedule 阶段入口
  function ensureRootIsScheduled(root) {
      const updateLane = getHighestPriorityLane(root.pendingLanes);
      if (updateLane == NoLane)
          return;
      if (updateLane === SyncLane) {
          // 同步优先级，用微任务调度
          {
              console.warn('在微任务中调度，优先级：', updateLane);
          }
          scheduleSyncCallback(renderRoot.bind(null, root, updateLane));
          scheduleMicroTask(flushSyncCallback);
      }
  }
  // Render 阶段入口
  function renderRoot(root, lane) {
      const nextLane = getHighestPriorityLane(root.pendingLanes);
      if (nextLane !== SyncLane) {
          // 其他比 SyncLane 低的优先级或 NoLane，重新调度
          ensureRootIsScheduled(root);
          return;
      }
      {
          console.warn('render 阶段开始');
      }
      // 初始化 workInProgress 变量
      prepareFreshStack(root, lane);
      do {
          try {
              // 深度优先遍历
              workLoop();
              break;
          }
          catch (e) {
              console.warn('workLoop发生错误：', e);
              workInProgress = null;
          }
      } while (true);
      if (workInProgress !== null) {
          console.error('render阶段结束时 workInProgress 不为 null');
      }
      // 创建根 Fiber 树的 Root Fiber
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      root.finishedLane = lane;
      workInProgressRenderLane = NoLane;
      // 提交阶段的入口函数
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.warn('commit 阶段开始');
      }
      const lane = root.finishedLane;
      markRootFinished(root, lane);
      // 重置
      root.finishedWork = null;
      root.finishedLane = NoLane;
      const { flags, subtreeFlags } = finishedWork;
      // 判断 Fiber 树是否存在副作用
      if ((flags & PassiveMask) !== NoFlags ||
          (subtreeFlags & PassiveMask) !== NoFlags) {
          if (!rootDoesHasPassiveEffects) {
              rootDoesHasPassiveEffects = true;
              // 调度副作用
              // 回调函数在 setTimeout 中以 NormalPriority 优先级被调度执行
              scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, () => {
                  // 执行副作用
                  flushPassiveEffects(root.pendingPassiveEffects);
                  return;
              });
          }
      }
      // 判断是否存在需要执行的 commit 操作
      if ((flags & MutationMask) !== NoFlags ||
          (subtreeFlags & MutationMask) !== NoFlags) {
          // TODO: BeforeMutation
          // Mutation
          commitMutationEffects(finishedWork, root);
          // Fiber 树切换，workInProgress 变成 current
          root.current = finishedWork;
          // TODO: Layout
      }
      else {
          root.current = finishedWork;
      }
      rootDoesHasPassiveEffects = false;
      ensureRootIsScheduled(root);
  }
  function flushPassiveEffects(pendingPassiveEffects) {
      // 先触发所有 unmount destroy
      pendingPassiveEffects.unmount.forEach((effect) => {
          commitHookEffectListUnmount(Passive, effect);
      });
      pendingPassiveEffects.unmount = [];
      // 再触发所有上次更新的 destroy
      pendingPassiveEffects.update.forEach((effect) => {
          commitHookEffectListDestory(Passive | HookHasEffect, effect);
      });
      // 再触发所有这次更新的 create
      pendingPassiveEffects.update.forEach((effect) => {
          commitHookEffectListCreate(Passive | HookHasEffect, effect);
      });
      pendingPassiveEffects.update = [];
      // 执行 useEffect 过程中可能触发新的更新
      // 再次调用 flushSyncCallback 处理这些更新的更新流程
      flushSyncCallback();
  }
  // 初始化 workInProgress 变量
  // 初始化 workInProgress 变量
  function prepareFreshStack(root, lane) {
      workInProgress = createWorkInProgress(root.current, {});
      workInProgressRenderLane = lane;
  }
  // 深度优先遍历，向下递归子节点
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      // 比较并返回子 FiberNode
      const next = beginWork(fiber, workInProgressRenderLane);
      fiber.memoizedProps = fiber.pendingProps;
      if (next == null) {
          // 没有子节点，则遍历兄弟节点或父节点
          completeUnitOfWork(fiber);
      }
      else {
          // 有子节点，继续向下深度遍历
          workInProgress = next;
      }
  }
  // 深度优先遍历，向下递归子节点
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          // 生成更新计划
          const next = completeWork(node);
          if (next !== null) {
              workInProgress = next;
              return;
          }
          // 有兄弟节点，则遍历兄弟节点
          const sibling = node.sibling;
          if (sibling !== null) {
              workInProgress = sibling;
              return;
          }
          // 否则向上返回，遍历父节点
          node = node.return;
          // workInProgress 最终指向根节点
          workInProgress = node;
      } while (node !== null);
  }
  // 调度功能
  function scheduleUpdateOnFiber(fiber, lane) {
      const root = markUpdateFromFiberToRoot(fiber);
      markRootUpdated(root, lane);
      ensureRootIsScheduled(root);
  }
  // 从触发更新的节点向上遍历到 FiberRootNode
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = node.return;
      while (parent !== null) {
          node = parent;
          parent = node.return;
      }
      if (node.tag == HostRoot) {
          return node.stateNode;
      }
      return null;
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRootFiber);
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current;
      const lane = requestUpdateLanes();
      const update = createUpdate(element, lane);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber, lane);
      return element;
  }

  /**
   * 实现 ReactDOM.createRoot(root).render(<App />);
   * createContainer 函数: 用于创建一个新的容器（container），该容器包含了 React 应用的根节点以及与之相关的一些配置信息。
   * updateContainer 函数: 用于更新已经存在的容器中的内容，将新的 React 元素（element）渲染到容器中，并更新整个应用的状态。
   * @param container
   * @returns
   */
  function createRoot(container) {
      const root = createContainer(container);
      return {
          render(element) {
              initEvent(container, 'click');
              return updateContainer(element, root);
          }
      };
  }

  var ReactDOM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDOM;

}));
